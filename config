#!/bin/bash
# author: mcncm
#
# Setup script to run mongodb server and activate
# python environment. Runs mongodb on default
# port (27017) in the default directory for dysart's
# debug database (./debug_data/db)
#
# Install by running `$ . config`.
# Run `$ dys on` to start the debug database server
# and python environment and `$ dys off` to turn
# them off.
#
# TODO: handle --help, -v, -q flags

DATETIME=`date '+%Y-%m-%d_%H:%M:%S'`
DB_NAME=debug_data
DB_PATH=$DB_NAME/db
LOG_PATH=$DB_NAME/log
DB_LOG_FILE=mongodb_$DATETIME.log
DUMMY_LAB_SERVER=dummy_server.py
DYS_LOG_FILE=dysart.log
PYTHON_VERSION="3.7"
PYENV_NAME=dysenv
CONDA=conda
VIRTUALENV=virtualenv
PYTHONSTARTUP_SCRIPT=dypy.py
DB_OFF=db_off
DB_ON=db_on
ENV_OFF=env_off
ENV_ON=env_on
ENV_NEXIST=env_nexist
ENV_NO_MANAGER=env_no_manager
LAB_OFF=lab_off
LAB_ON=lab_on

# Display and pretty-printing
fg_red="$(tput setaf 1)"
fg_green="$(tput setaf 2)"
reset="$(tput sgr0)"
DONE_STR="${fg_green}done.${reset}"
ON_STR="${fg_green}ON${reset}"
OFF_STR="${fg_red}OFF${reset}"
NONE_STR="${fg_red}NONE${reset}"
export STATUS_COL=48

#TODO: retrieve this list externally!
REQUIREMENTS={numpy,lmfit,pymongo,mongoengine,h5py,jsonschema,matplotlib,pint,pyqt5}
CONDA_REQUIREMENTS={python.app,}
VIRTUALENV_REQUIREMENTS={}

# Regex for positive integers
integral='^[0-9]+$'

function echo_help {
	COL_WIDTH=28
	echo "Here are some dysart commands you can try out:"
	printf "%-"$COL_WIDTH"s" "    on" && echo "start python environment and database"
	printf "%-"$COL_WIDTH"s" "    off" && echo "stop python environment and database"
	printf "%-"$COL_WIDTH"s" "    restart" && echo "turn it off and on again"
	printf "%-"$COL_WIDTH"s" "    help" && echo "this help page"
	printf "%-"$COL_WIDTH"s" "    labber" && echo ""
	printf "%-"$COL_WIDTH"s" "        /path/to/Labber" && echo "link Labber to DySART"
	printf "%-"$COL_WIDTH"s" "    status" && echo "the status of installed services"
	printf "%-"$COL_WIDTH"s" "    log" && echo "read the dysart log file"
	printf "%-"$COL_WIDTH"s" "    clean" && echo ""
	printf "%-"$COL_WIDTH"s" "        env" && echo "remove python environment"
	printf "%-"$COL_WIDTH"s" "        db" && echo "clear database"
	printf "%-"$COL_WIDTH"s" "        log" && echo "clear log files"
	printf "%-"$COL_WIDTH"s" "        profile" && echo "remove modifications to bash profile"
	printf "%-"$COL_WIDTH"s" "        hard" && echo "all of the above"
	printf "%-"$COL_WIDTH"s" "    uninstall" && echo "the hardest clean"
	printf "%-"$COL_WIDTH"s" "    proj" && echo "set the default project tree"
	printf "%-"$COL_WIDTH"s" "        /path/to/proj.py" && echo "set default project tree"
	printf "%-"$COL_WIDTH"s" "        none" && echo "no default project"
}

function create_db {
	# If database location is missing, make it!
	if [[ ! -d $DYS_PATH/$DB_PATH ]]; then
		echo "Creating debug database..."
		mkdir -p $DYS_PATH/$DB_PATH
	fi

	# If database log is missing, make it!
	if [[ ! -d $DYS_PATH/$LOG_PATH ]]; then
		echo "Creating database log..."
		mkdir -p $DYS_PATH/$LOG_PATH
	fi
}

function find_env_manager {
	# Figure out how environments are managed.
	# Return a code for each manager type, with
	# preference from low to high.
	# conda: 1
	# virtualenv: 2

	CONDA_VERSION=`conda -V 2>/dev/null`
	VIRTUALENV_PATH=`which virtualenv`

	if [[ ! -z $CONDA_VERSION ]] ; then
		ENV_MANAGER=$CONDA
	elif [[ ! -z $VIRTUALENV_PATH ]] ; then
		ENV_MANAGER=$VIRTUALENV
	else
		ENV_MANAGER=0
	fi

	echo $ENV_MANAGER
}

function install_requirements {
	# Figure out how environments are managed;
	# Locate an install all required packages.
	# TODO: there are "correct" ways to do this
	# for each environment management tool, and
	# this is not one of them.
	ENV_MANAGER=`find_env_manager`
	# Note the redundancy here. This is because I
	# previously used two different solutions for each
	# manager, and a hint that I might again in the future.
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		# Assumes you are already in the environment!
		eval "pip install $REQUIREMENTS"
		eval "conda install -y $CONDA_REQUIREMENTS"
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		# Assumes you are already in the environment!
		eval "pip install $REQUIREMENTS"
	else
		echo "Unknown environment management tool. No packages to install."
	fi
}

function create_env {
	# Figure out how environments are managed;
	# Create the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		# Check whether Conda env exists. If not,
		# make one!
		if [[ -z `conda info -e | grep $PYENV_NAME` ]] ; then
			activate_env
			echo "Creating python environment..."
			conda create -y -n $1 python=$PYTHON_VERSION
			deactivate_env
		fi
	elif [[ $ENV_MANAGER = $VIRTUALENV ]]; then
		if [[ ! -d $DYS_PATH/$1 ]] ; then
			activate_env
			echo "Creating python environment..."
			virtualenv $DYS_PATH/$1 --python=python$PYTHON_VERSION
			deactivate_env
		fi
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi

}

function activate_env {
	# Figure out how environments are managed;
	# Activate the correct environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		printf "%-"$STATUS_COL"s" "activating python environment..."
		conda activate $1
    	printf "%s\n" $DONE_STR
	elif [[ $ENV_MANAGER = $VIRTUALENV ]]; then
		# Just activate the environment.
		printf "%-"$STATUS_COL"s" "activating python environment..."
		source $DYS_PATH/$1/bin/activate
    	printf "%s\n" $DONE_STR
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi
}

function deactivate_env {
	# Figure out how environments are managedl
	# Deactivate the correct environment.
	ENV_MANAGER=`find_env_manager`
 	printf "%-"$STATUS_COL"s" "deactivating python environment..."
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		conda deactivate
    	printf "%s\n" $DONE_STR
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		deactivate
    	printf "%s\n" $DONE_STR
	else
		echo "There appears to be no python \\
		environment management tool installed."
		echo "Try conda or virtualenv!"
	fi
}

function env_get_status {
	# Checks if the python environment is activated.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		if [[ ! -z `conda info -e | grep \*.*$PYENV_NAME` ]] ; then
			ENV_STATUS=$ENV_ON
		elif [[ -z `conda info -e | grep $PYENV_NAME` ]] ; then
			ENV_STATUS=$ENV_NEXIST
		else
			ENV_STATUS=$ENV_OFF
		fi
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		if [[ -d $DYS_PATH/$PYENV_NAME ]] ; then
			if [[ ! -z `echo $VIRTUAL_ENV | grep $PYENV_NAME` ]] ; then
				ENV_STATUS=$ENV_ON
			else
				ENV_STATUS=$ENV_OFF
			fi
		else
			ENV_STATUS=$ENV_NEXIST
		fi
	else
		ENV_STATUS=$ENV_NO_MANAGER
	fi

  export ENV_STATUS
}

function db_get_status {
	# Checks if database server is already running.
	# Returns process id if it is.
	PID=$(pgrep mongod)
	if [[ ! -z $PID ]] ; then
		DB_STATUS=$PID
	else
		DB_STATUS=$DB_OFF
	fi

	export DB_STATUS
}

function lab_get_status {
	# Checks if the dummy lab server is running.
	# If not, return the special $LAB_OFF signal.
	# If on, return its process id.
	RE="$(echo $DUMMY_LAB_SERVER | sed 's/^\(.\)/[\1]/')"
	PID=$(ps | grep "$RE" | awk 'NR=1{print $1}')
	if [[ -z $PID ]] ; then
		LAB_STATUS=$LAB_OFF
	else
		LAB_STATUS=$PID
	fi
	export LAB_STATUS
}

function start_db {
	# Run the mongodb database
	db_get_status
	if [[ $DB_STATUS = $DB_OFF ]] ; then
		printf "%-"$STATUS_COL"s" "starting database on default port..."
		mongod --quiet --logpath $DYS_PATH/$LOG_PATH/$DB_LOG_FILE\
		 --dbpath $DYS_PATH/$DB_PATH &
    printf "%s\n" $DONE_STR
	# If DB_STATUS is a positive integer, it's a process id.
	# This could be considered bad practice leaking in, since db_get_status
	# doesn't have a single, well-defined return type.
	elif [[ $DB_STATUS =~ $integral ]] ; then
		echo "database already running."
	fi
  db_get_status
}

function stop_db {
	# This doesn't work with MacOS/MongoDB:
	# mongod --shutdown --dbpath $DB_PATH
	db_get_status
	if [[ $DB_STATUS = $DB_OFF ]] ; then
		echo "database already off."
	# Check to see if $DB_STATUS corresponds to a process id; if so, kill it.
	elif [[ $DB_STATUS =~ $integral ]] ; then
		echo "shutting down database server..."
		kill $DB_STATUS
		# Temporary safety feature
    # TODO: figure out if this is necesssary
		sleep 1
	fi
  db_get_status
}

function start_lab {
	# Runs the dummy lab
	# find the actual full path to the binary! This is necessary because
	# we will alias `python` to connect to the database server.
	SERVER_SCRIPT=$DYS_PATH/dysart/measurement/$DUMMY_LAB_SERVER
	PYTHON_BINARY=`which python`
	echo "Starting dummy lab server..."
	$PYTHON_BINARY $SERVER_SCRIPT &
}

function stop_lab {
	lab_get_status
	if [[ $LAB_STATUS =~ $numeric ]] ; then
		# LAB_STATUS is a process id
		echo "Shutting down dummy lab server..."
		kill $LAB_STATUS
	else
		echo "Dummy lab already off."
	fi
  lab_get_status
}

function init_dys_log {
	# If the DySART logfile doesn't exist, make it!
	if [[ ! -f $DYS_PATH/$LOG_PATH/$DYS_LOG_FILE ]] ; then
		touch $DYS_PATH/$LOG_PATH/$DYS_LOG_FILE
	fi
}

function start {
	# Activate python environment
	if [[ ! -z $STARTED ]] ; then
		if [[ $STARTED -eq 1 ]] ; then
			echo "Already on!"
			return 0
		fi
	fi
	activate_env $PYENV_NAME
  # Make sure the python interpreter's startup script is correct. Keep the old
  # one so you can restore it on stop. (Should this go in dysenv?)
  export OLD_PYTHONSTARTUP=$PYTHONSTARTUP
  export PYTHONSTARTUP=$DYS_PATH/dysart/clients/$PYTHONSTARTUP_SCRIPT
  # Add to pythonpath
  export OLD_PYTHONPATH=$PYTHONPATH
  export PYTHONPATH=$DYS_PATH/dysart
  # Start the database server
	start_db
  # Initialize the log
	init_dys_log
	export STARTED=1
}

function stop {
	# Deactivate python environment; stop db server
	if [[ ! -z $STARTED ]] ; then
		if [[ $STARTED -ne 0 ]] ; then
			# TODO: This doesn't work with MacOS MongoDB
			deactivate_env
      # Restore original python startup script
      export PYTHONSTARTUP=$OLD_PYTHONSTARTUP
      # Restore original pythonpath
      export PYTHONPATH=$OLD_PYTHONPATH
      # Stop the database server
			stop_db
			export STARTED=0
		fi
	else
		echo "Already off!"
	fi
}

function restart {
	# Cycle the system
	stop
	start
}

function echo_status {
	# Prints status information on db server and python environment
	db_get_status
	env_get_status
	lab_get_status
	#tree_get_status
	# Print db server information
	if [[ $DB_STATUS =~ $integral ]] ; then
		printf "%-"$STATUS_COL"s%s\n" database $ON_STR
	elif [[ $DB_STATUS = $DB_OFF ]] ; then
		printf "%-"$STATUS_COL"s%s\n" database $OFF_STR
	else
		echo "unknown database status"
	fi
	# Print python environment information
	if [[ $ENV_STATUS = $ENV_ON ]] ; then
		printf "%-"$STATUS_COL"s%s\n" $PYENV_NAME $ON_STR
	elif [[ $ENV_STATUS = $ENV_OFF ]] ; then
		printf "%-"$STATUS_COL"s%s\n" $PYENV_NAME $OFF_STR
	elif [[ $ENV_STATUS = $ENV_NEXIST ]] ; then
		echo "python environment does not exist"
	elif [[ $ENV_STATUS = $ENV_NO_MANAGER ]] ; then
		echo "no recognized python environment manager"
	else
		echo "unkown python environment status"
	fi
	# Print dummy lab information
	if [[ $LAB_STATUS =~ $integral ]] ; then
		printf "%-"$STATUS_COL"s%s\n" "dummy lab" $ON_STR
	elif [[ $LAB_STATUS = $LAB_OFF ]] ; then
		printf "%-"$STATUS_COL"s%s\n" "dummy lab" $OFF_STR
	else
		echo "unknown dummy lab status"
	fi
	# Print default tree information
	if [[ -z $DEFAULT_TREE ]] ; then
		printf "%-"$STATUS_COL"s%s\n" "default tree" $NONE_STR
	else
		TREE_STR="${fg_green}$(basename $DEFAULT_TREE)${reset}"
		printf "%-"$STATUS_COL"s%s\n" "default tree" $TREE_STR
	fi
}

function clean {
	# Parse inputs to clean commant and pass
	# control to desired operation
	if [[ -z $1 ]] ; then
		clean_hard
	else
		case $1 in
			hard)		clean_hard	;;
			env)		clean_env	;;
			db)			clean_db 	;;
			database)	clean_db 	;;
			log)		clean_log	;;
			profile)	clean_profile	;;
			*)			echo "I don't understand that." ;;
		esac
	fi
}

function clean_hard {
	# Shut everything off
	stop
	# Clear environment and database
	clean_env
	clean_db
	clean_log
	clean_profile
}

function clean_env {
	# Delete python environment.
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		echo "About to delete python environment $PYENV_NAME."
		read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
		if [[ $DEL_INPUT = "y" ]] ; then
			conda env remove -n $PYENV_NAME
		fi
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		PYENV_PATH=`pwd`/$PYENV_NAME
		echo "About to recursively delete directory $PYENV_PATH"
		read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
		if [[ $DEL_INPUT = "y" ]] ; then
			rm -rf $PYENV_NAME
		fi
	else
		echo "Unknown environment management tool. No known environment."
	fi
}

function clean_db {
	# Stop database server if necessary
	db_get_status
	if [[ $DB_STATUS = $DB_ON ]] ; then
		stop_db
	fi
	# Empty database directory.
	FULL_DB_PATH=$DYS_PATH/$DB_NAME/db
	echo "About to recursively empty directory $FULL_DB_PATH"
	read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
	if [[ $DEL_INPUT = "y" ]] ; then
		rm -rf $FULL_DB_PATH/*
	fi
	# Restart database server if it was previously shut off
	if [[ $DB_STATUS = $DB_ON ]] ; then
		start_db
	fi
}

function clean_log {
	# Stop database server
	stop_db
	# Empty log directory.
	FULL_LOG_PATH=$DYS_PATH/$DB_NAME/log
	echo "About to recursively empty directory $FULL_LOG_PATH"
	read -p ">>> Are you sure ([y]/n)? " DEL_INPUT
	if [[ $DEL_INPUT = 'y' ]] ; then
		rm -rf $FULL_LOG_PATH/*
	fi
	# Restart database server again
	start_db
}

function read_log {
  # Display the log contents
	FULL_LOG_PATH=$DYS_PATH/$DB_NAME/log
  less $FULL_LOG_PATH/$DYS_LOG_FILE
}

function get_profile {
	# Figures out which of user's dotfiles to modify
	if [[ $OSTYPE == darwin* ]] ; then
		PROFILE=$HOME/.bash_profile
	elif [[ $OSTYPE == linux-gnu ]] ; then
		PROFILE=$HOME/.bashrc
	elif [[ $OSTYPE == freebsd* ]] ; then
		echo "We get it, you're extremely l33t"
	else
		echo "Sorry, I'm not sure how to finish installation for your OS."
	fi
	echo $PROFILE
}

function write_profile {
	# Aliases `dys` to . ./config
	# First argument should be full path to top-level directory
	PROFILE=$(get_profile)
	BASENAME=$(basename \`$PROFILE\`)
	if [[ ! $(cat $PROFILE | grep "dysart config") ]] ; then
		echo "Installer would like to modify your $BASENAME"
		read -p ">>> Are you sure ([y]/n)? " MOD_INPUT
		if [[ $MOD_INPUT = 'y' ]] ; then
			CONTENT="# >>> dysart config >>>\n"
			CONTENT+="# Added by DySART installer\n"
			CONTENT+="alias dys=\". "$1"/config\"\n"
			CONTENT+="export DYS_PATH=$1\n"
			CONTENT+="# <<< dysart config <<<\n"
			echo -e $CONTENT"$(cat $PROFILE)" > $PROFILE
		fi
	fi
}

function clean_profile {
	PROFILE=$(get_profile)
	BASENAME=$(basename $PROFILE)
	echo "Installer would like to modify your $BASENAME"
	read -p ">>> Are you sure ([y]/n)? " MOD_INPUT
	if [[ $MOD_INPUT = 'y' ]] ; then
		if [[ $OSTYPE == darwin* ]] ; then
			sed -i '' '/# >>> dysart config/,/dysart config <<</d' $PROFILE
		elif [[ $OSTYPE == linux-gnu ]] ; then
			sed -i '/# >>> dysart config/,/dysart config <<</d' $PROFILE
		else
			"Sorry, I'm not sure how to clean the profile in your OS."
		fi
	fi
}

function get_profile {
	# Figures out which of user's dotfiles to modify
	if [[ $OSTYPE == darwin* ]] ; then
		PROFILE=$HOME/.bash_profile
	elif [[ $OSTYPE == linux-gnu ]] ; then
		PROFILE=$HOME/.bashrc
	elif [[ $OSTYPE == freebsd* ]] ; then
		echo "yes, you're extremely l33t"
	else
		echo "Sorry, I'm not sure how to finish installation for your OS."
	fi
	echo $PROFILE
}

function link_labber {
	# Set up labber installation for use with python environment
	# $1 is path to Labber installation
	ENV_MANAGER=`find_env_manager`
	if [[ $ENV_MANAGER = $CONDA ]] ; then
		# Get the full true path to the conda environment
		FULL_ENV_PATH=`conda info -e | grep -o '/.*'$PYENV_NAME'$'`
		# Unlink. Don't use ln -f because its behavior is
		# platform-dependent (?)
		FULL_LINK_PATH=$FULL_ENV_PATH/lib/python$PYTHON_VERSION/Labber
		if [[ ! -z `readlink $FULL_LINK_PATH` ]] ; then
			unlink $FULL_LINK_PATH
		fi
		# Link the labber installation
		ln -s $1/Script/Labber $FULL_LINK_PATH
	elif [[ $ENV_MANAGER = $VIRTUALENV ]] ; then
		FULL_LINK_PATH=$DYS_PATH/$PYENV_NAME/lib/python$PYTHON_VERSION/site-packages/Labber
		if [[ ! -z `readlink $FULL_LINK_PATH` ]] ; then
			unlink $FULL_LINK_PATH
		fi
		ln -s $1/Script/Labber $FULL_LINK_PATH
	else
		echo "Unknown environment management tool."
		echo "I'm not sure how to configure Labber."
	fi
}

# Note: unlink_labber isn't really necessary, since uninstall will erase
# whole python environment.

function install {
	# If not already installed,
	# write the dys alias to correct profile dotfile
	if [[ -z `type -t dys` ]] ; then
		PROFILE=$(get_profile)
		if [[ -z $(cat $PROFILE | grep dys) ]] ; then
			write_profile `pwd`
		fi
		source $PROFILE

		# Create python environment
		create_env $PYENV_NAME
		activate_env $PYENV_NAME
		install_requirements

		# Create database
		create_db
	fi
}

function uninstall {
	# Get rid of all the stuff the installation pollutes your system with.
	clean hard
	unalias dys
}

function set_project_tree {
	# Configure the default project tree by exporting the DEFAULT_TREE variable
	if [[ ! -z $1 ]] ; then
		if [[ $1 == "none"  ]] ; then
			export DEFAULT_TREE=""
			echo "default project tree removed."
		else
			export DEFAULT_TREE=$(realpath "$1")
			echo "default project tree set."
		fi
	else
		echo "default project tree is "$DEFAULT_TREE
	fi
}


#####################
# SETUP SCRIPT BODY #
#####################

# Parse input to enter python environment and start db server
if [[ $# -ne 0 ]]; then
	case $1 in
		on)					start										;;
		start)			start										;;
		run)				start										;;
		go)					start										;;
		begin)			start										;;
		stop)				stop										;;
		end)				stop										;;
		quit)				stop										;;
		exit)				stop										;;
		finish)			stop										;;
		off) 				stop										;;

		restart) 		restart									;;
		reboot) 		restart									;;
		cycle)			restart									;;

		help)				echo_help								;;
		status)			echo_status						 	;;
    log)		  	read_log 								;;

		proj)				set_project_tree $2			;;

		install)		install									;;
		uninstall)	uninstall								;;
		clean)			clean $2								;;
		update)			install_requirements		;;
		upgrade)		install_requirements		;;

		labber)			link_labber $2					;;
		Labber)			link_labber $2					;;

		*) echo "I don't understand that."	;;
	esac
else
	if [[ -z $(type -t dys ) ]] ; then
		# The first time it is run, do the installation!
		install
	else
		# Otherwise, print the help string
		echo_help
	fi
fi

# Export environment variables
export DB_STATUS
